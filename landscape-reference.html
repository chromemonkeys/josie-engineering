<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Wind Farm Valley — Low Poly Landscape</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { overflow: hidden; background: #1a1a2e; font-family: 'Segoe UI', sans-serif; }
  canvas { display: block; }
  #vignette {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 5;
    background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.5) 100%);
  }
  #title {
    position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%);
    z-index: 20; text-align: center; pointer-events: none;
  }
  #title h1 {
    font-family: 'Georgia', serif;
    font-size: 2.5rem; font-weight: 300; letter-spacing: 0.3em;
    color: rgba(255,255,255,0.85);
    text-shadow: 0 2px 20px rgba(0,0,0,0.5);
    animation: fadeUp 2s ease-out 0.5s both;
  }
  #title p {
    font-size: 0.85rem; letter-spacing: 0.5em; text-transform: uppercase;
    color: rgba(255,255,255,0.4); margin-top: 8px;
    animation: fadeUp 2s ease-out 1s both;
  }
  @keyframes fadeUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
  }
</style>
</head>
<body>
<div id="vignette"></div>
<div id="title">
  <h1>Wind Farm Valley</h1>
  <p>A low poly landscape</p>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ─── SCENE SETUP ───
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
document.body.appendChild(renderer.domElement);

scene.fog = new THREE.FogExp2(0xd4a574, 0.012);
renderer.setClearColor(0xd4a574);

// ─── DETERMINISTIC HASH FOR CONSISTENT PLACEMENT ───
function hash(x, z) {
  let n = Math.sin(x * 127.1 + z * 311.7) * 43758.5453;
  return n - Math.floor(n);
}

// ─── TERRAIN HEIGHT FUNCTION (single source of truth) ───
function terrainHeight(x, z) {
  let y = 0;
  y += Math.sin(x * 0.04) * 3 + Math.cos(z * 0.05) * 2.5;
  y += Math.sin(x * 0.08 + z * 0.06) * 1.5;
  y += Math.sin(x * 0.15) * Math.cos(z * 0.12) * 0.8;
  // Fine variation
  y += (Math.sin(x * 0.7 + z * 0.3) * 0.3);
  // Valley in center
  const dist = Math.sqrt(x * x + z * z);
  y -= Math.max(0, 3 - dist * 0.06);
  return y;
}

// ─── SKY ───
const skyGeo = new THREE.SphereGeometry(200, 32, 32);
const skyMat = new THREE.ShaderMaterial({
  uniforms: {
    topColor: { value: new THREE.Color(0x1a1a4e) },
    midColor: { value: new THREE.Color(0xe8836b) },
    bottomColor: { value: new THREE.Color(0xf5c882) },
    sunColor: { value: new THREE.Color(0xffe4a0) },
    sunPos: { value: new THREE.Vector3(0.3, 0.05, -1.0) },
    offset: { value: 10 },
    exponent: { value: 0.5 }
  },
  vertexShader: `
    varying vec3 vWorldPosition;
    void main() {
      vec4 worldPos = modelMatrix * vec4(position, 1.0);
      vWorldPosition = worldPos.xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 topColor, midColor, bottomColor, sunColor, sunPos;
    uniform float offset, exponent;
    varying vec3 vWorldPosition;
    void main() {
      float h = normalize(vWorldPosition + offset).y;
      float t = max(pow(max(h, 0.0), exponent), 0.0);
      vec3 col;
      if (t < 0.3) col = mix(bottomColor, midColor, t / 0.3);
      else col = mix(midColor, topColor, (t - 0.3) / 0.7);
      vec3 dir = normalize(vWorldPosition);
      float sunDot = max(dot(dir, normalize(sunPos)), 0.0);
      col += sunColor * pow(sunDot, 32.0) * 1.5;
      col += sunColor * pow(sunDot, 4.0) * 0.3;
      gl_FragColor = vec4(col, 1.0);
    }
  `,
  side: THREE.BackSide
});
scene.add(new THREE.Mesh(skyGeo, skyMat));

// ─── LIGHTING ───
scene.add(new THREE.AmbientLight(0x8899bb, 0.4));

const sunLight = new THREE.DirectionalLight(0xffe0b2, 1.8);
sunLight.position.set(30, 25, -50);
sunLight.castShadow = true;
sunLight.shadow.mapSize.set(2048, 2048);
sunLight.shadow.camera.near = 0.5;
sunLight.shadow.camera.far = 150;
sunLight.shadow.camera.left = -60;
sunLight.shadow.camera.right = 60;
sunLight.shadow.camera.top = 60;
sunLight.shadow.camera.bottom = -60;
sunLight.shadow.bias = -0.001;
scene.add(sunLight);

scene.add(new THREE.DirectionalLight(0x6688cc, 0.3).translateX(-20).translateY(10).translateZ(30));
scene.add(new THREE.DirectionalLight(0xff8855, 0.5).translateY(5).translateZ(-40));

// ─── TERRAIN MESH ───
function createTerrain() {
  const geo = new THREE.PlaneGeometry(160, 160, 80, 80);
  geo.rotateX(-Math.PI / 2);
  const pos = geo.attributes.position;
  const colors = [];

  for (let i = 0; i < pos.count; i++) {
    const x = pos.getX(i);
    const z = pos.getZ(i);
    const y = terrainHeight(x, z);
    pos.setY(i, y);

    const nf = hash(x * 10, z * 10);
    let col;
    if (y > 3) col = new THREE.Color(0x8fb565).lerp(new THREE.Color(0x6ba358), nf);
    else if (y > 0) col = new THREE.Color(0x6ba358).lerp(new THREE.Color(0x4a7c3f), nf);
    else col = new THREE.Color(0x4a7c3f).lerp(new THREE.Color(0x2d5a27), nf);
    col.lerp(new THREE.Color(0xd4a060), 0.08);
    colors.push(col.r, col.g, col.b);
  }

  geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
  geo.computeVertexNormals();
  const flatGeo = geo.toNonIndexed();
  flatGeo.computeVertexNormals();

  const mesh = new THREE.Mesh(flatGeo, new THREE.MeshLambertMaterial({ vertexColors: true, flatShading: true }));
  mesh.receiveShadow = true;
  scene.add(mesh);
  return mesh;
}

// ─── WATER ───
function createWater() {
  const geo = new THREE.PlaneGeometry(160, 160, 1, 1);
  geo.rotateX(-Math.PI / 2);
  const mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({
    color: 0x3a7ca5, transparent: true, opacity: 0.65,
    shininess: 100, specular: 0xffffff, flatShading: true
  }));
  mesh.position.y = -2.5;
  scene.add(mesh);
  return mesh;
}

// ─── MODERN WIND TURBINE ───
function createWindTurbine(x, z, scale = 1, towerH = 14) {
  const group = new THREE.Group();
  const h = towerH * scale;
  const s = scale;

  // Tower - tall sleek tapered
  const towerGeo = new THREE.CylinderGeometry(0.15 * s, 0.5 * s, h, 8);
  const tower = new THREE.Mesh(towerGeo, new THREE.MeshLambertMaterial({ color: 0xeaeaea, flatShading: true }));
  tower.position.y = h / 2;
  tower.castShadow = true;
  group.add(tower);

  // Nacelle housing
  const nacelleGeo = new THREE.BoxGeometry(0.45 * s, 0.35 * s, 1.4 * s);
  const nacelle = new THREE.Mesh(nacelleGeo, new THREE.MeshLambertMaterial({ color: 0xf0f0f0, flatShading: true }));
  nacelle.position.set(0, h + 0.1 * s, 0.2 * s);
  nacelle.castShadow = true;
  group.add(nacelle);

  // Hub cone
  const hubGeo = new THREE.ConeGeometry(0.22 * s, 0.7 * s, 6);
  const hub = new THREE.Mesh(hubGeo, new THREE.MeshLambertMaterial({ color: 0xdddddd, flatShading: true }));
  hub.rotation.x = -Math.PI / 2;
  hub.position.set(0, h + 0.1 * s, 0.95 * s);
  hub.castShadow = true;
  group.add(hub);

  // Rotor pivot (3 blades)
  const rotorPivot = new THREE.Group();
  rotorPivot.position.set(0, h + 0.1 * s, 1.0 * s);

  const bladeLen = 7.0 * s;
  const bladeMat = new THREE.MeshLambertMaterial({ color: 0xf5f5f5, flatShading: true });

  for (let i = 0; i < 3; i++) {
    const bladeGroup = new THREE.Group();
    bladeGroup.rotation.z = (Math.PI * 2 / 3) * i;

    // Tapered blade: 3 segments root → mid → tip
    const r = new THREE.Mesh(new THREE.BoxGeometry(0.35 * s, bladeLen * 0.35, 0.06 * s), bladeMat);
    r.position.y = bladeLen * 0.18;
    r.castShadow = true;
    bladeGroup.add(r);

    const m = new THREE.Mesh(new THREE.BoxGeometry(0.22 * s, bladeLen * 0.35, 0.05 * s), bladeMat);
    m.position.y = bladeLen * 0.52;
    m.castShadow = true;
    bladeGroup.add(m);

    const tip = new THREE.Mesh(new THREE.BoxGeometry(0.1 * s, bladeLen * 0.32, 0.03 * s), bladeMat);
    tip.position.y = bladeLen * 0.84;
    tip.castShadow = true;
    bladeGroup.add(tip);

    rotorPivot.add(bladeGroup);
  }

  group.add(rotorPivot);
  group.rotorPivot = rotorPivot;

  // Concrete base
  const baseGeo = new THREE.CylinderGeometry(0.9 * s, 1.1 * s, 0.25 * s, 6);
  const base = new THREE.Mesh(baseGeo, new THREE.MeshLambertMaterial({ color: 0x999999, flatShading: true }));
  base.position.y = 0.12 * s;
  base.castShadow = true;
  group.add(base);

  // Snap to terrain
  const ty = terrainHeight(x, z);
  group.position.set(x, Math.max(ty, -1), z);
  scene.add(group);
  return group;
}

// ─── TREES (snapped to terrain) ───
function createTree(x, z, type) {
  const ty = terrainHeight(x, z);
  if (ty < -1.5) return null;

  const group = new THREE.Group();

  if (type === 'pine') {
    const trunk = new THREE.Mesh(
      new THREE.CylinderGeometry(0.1, 0.15, 1.5, 5),
      new THREE.MeshLambertMaterial({ color: 0x6b4226, flatShading: true })
    );
    trunk.position.y = 0.75;
    trunk.castShadow = true;
    group.add(trunk);

    [[0.9, 1.5, 0x2d6b30], [0.65, 2.5, 0x3a8c3f], [0.4, 3.3, 0x4da34f]].forEach(([r, h, c]) => {
      const cone = new THREE.Mesh(
        new THREE.ConeGeometry(r, 1.2, 6),
        new THREE.MeshLambertMaterial({ color: c, flatShading: true })
      );
      cone.position.y = h;
      cone.castShadow = true;
      group.add(cone);
    });
  } else {
    const trunk = new THREE.Mesh(
      new THREE.CylinderGeometry(0.08, 0.12, 1.2, 5),
      new THREE.MeshLambertMaterial({ color: 0x7a5230, flatShading: true })
    );
    trunk.position.y = 0.6;
    trunk.castShadow = true;
    group.add(trunk);

    const leaves = new THREE.Mesh(
      new THREE.IcosahedronGeometry(0.9, 0),
      new THREE.MeshLambertMaterial({
        color: new THREE.Color().setHSL(0.28 + hash(x, z) * 0.08, 0.55, 0.38),
        flatShading: true
      })
    );
    leaves.position.y = 1.8;
    leaves.scale.set(1, 1.2, 1);
    leaves.castShadow = true;
    group.add(leaves);
  }

  const sc = 0.6 + hash(x * 3, z * 7) * 0.8;
  group.scale.set(sc, sc, sc);
  group.rotation.y = hash(x, z * 5) * Math.PI * 2;
  group.position.set(x, ty, z);
  scene.add(group);
  return group;
}

// ─── ROCKS (snapped & sunk into terrain) ───
function createRock(x, z) {
  const ty = terrainHeight(x, z);
  if (ty < -2) return null;

  const geo = new THREE.DodecahedronGeometry(0.3 + hash(x, z) * 0.6, 0);
  const rock = new THREE.Mesh(geo, new THREE.MeshLambertMaterial({
    color: new THREE.Color().setHSL(0.08, 0.1, 0.35 + hash(x * 2, z * 3) * 0.2),
    flatShading: true
  }));
  // Sink into ground so bottom half is buried
  const rockScale = 0.5 + hash(x * 5, z) * 0.3;
  rock.position.set(x, ty - 0.1, z);
  rock.rotation.set(hash(x, z), hash(z, x), hash(x + z, z - x));
  rock.scale.set(1, rockScale, 1);
  rock.castShadow = true;
  scene.add(rock);
  return rock;
}

// ─── FLOWERS (snapped to terrain) ───
function createFlowerPatch(cx, cz) {
  const cty = terrainHeight(cx, cz);
  if (cty < -1) return;

  const flowerColors = [0xff6b9d, 0xffd93d, 0xff8a5c, 0xc56cf0, 0xffffff, 0xff4757];
  const count = 5 + Math.floor(hash(cx, cz) * 8);
  for (let i = 0; i < count; i++) {
    const fx = cx + (hash(i * 13, cz) - 0.5) * 3;
    const fz = cz + (hash(cx, i * 17) - 0.5) * 3;
    const fy = terrainHeight(fx, fz);
    if (fy < -1.5) continue;

    const stem = new THREE.Mesh(
      new THREE.CylinderGeometry(0.01, 0.015, 0.3, 3),
      new THREE.MeshLambertMaterial({ color: 0x3a7a3a, flatShading: true })
    );
    stem.position.set(fx, fy + 0.15, fz);
    scene.add(stem);

    const head = new THREE.Mesh(
      new THREE.SphereGeometry(0.06 + hash(fx, fz) * 0.05, 4, 3),
      new THREE.MeshLambertMaterial({
        color: flowerColors[Math.floor(hash(fx * 3, fz * 7) * flowerColors.length)],
        flatShading: true
      })
    );
    head.position.set(fx, fy + 0.32, fz);
    scene.add(head);
  }
}

// ─── CLOUDS ───
const clouds = [];
function createCloud(x, y, z) {
  const group = new THREE.Group();
  const mat = new THREE.MeshLambertMaterial({ color: 0xfff5e6, flatShading: true, transparent: true, opacity: 0.85 });
  const n = 4 + Math.floor(hash(x, z) * 4);
  for (let i = 0; i < n; i++) {
    const puff = new THREE.Mesh(new THREE.IcosahedronGeometry(1 + hash(i, x) * 1.5, 1), mat);
    puff.position.set((hash(i * 3, z) - 0.5) * 4, (hash(i, x * 2) - 0.5) * 0.8, (hash(x, i * 5) - 0.5) * 2);
    puff.scale.y = 0.5 + hash(i * 7, z) * 0.3;
    group.add(puff);
  }
  group.position.set(x, y, z);
  const s = 0.8 + hash(x, z) * 1.2;
  group.scale.set(s, s * 0.5, s);
  scene.add(group);
  clouds.push(group);
}

// ─── BIRDS ───
const birds = [];
function createBird(x, y, z) {
  const group = new THREE.Group();
  const mat = new THREE.MeshLambertMaterial({ color: 0x2c2c2c, flatShading: true });
  const wL = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.02, 0.15), mat);
  wL.position.x = -0.3; wL.rotation.z = 0.3; group.add(wL);
  const wR = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.02, 0.15), mat);
  wR.position.x = 0.3; wR.rotation.z = -0.3; group.add(wR);
  group.position.set(x, y, z);
  group.userData = { baseY: y, speed: 0.3 + hash(x, z) * 0.5, angle: hash(x, z) * Math.PI * 2, radius: 10 + hash(z, x) * 20, flapSpeed: 3 + hash(x * 2, z) * 3 };
  scene.add(group);
  birds.push(group);
}

// ─── PARTICLES ───
function createParticles() {
  const count = 200;
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count * 3);
  for (let i = 0; i < count * 3; i += 3) {
    pos[i] = (hash(i, i + 1) - 0.5) * 100;
    pos[i + 1] = hash(i + 2, i) * 20 + 2;
    pos[i + 2] = (hash(i + 3, i + 4) - 0.5) * 100;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  const pts = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffeebb, size: 0.08, transparent: true, opacity: 0.6, sizeAttenuation: true }));
  scene.add(pts);
  return pts;
}

// ─── BUILD SCENE ───
createTerrain();
const water = createWater();

const turbines = [];
const turbinePos = [
  { x: -5, z: -18, s: 1.0, h: 14 },
  { x: 15, z: -10, s: 0.9, h: 13 },
  { x: -20, z: 3, s: 0.85, h: 12 },
  { x: 8, z: 14, s: 1.0, h: 14 },
  { x: -32, z: -22, s: 0.75, h: 11 },
  { x: 28, z: -20, s: 0.9, h: 13 },
  { x: -12, z: 28, s: 0.7, h: 10 },
  { x: 22, z: 8, s: 0.85, h: 12 },
];
turbinePos.forEach(p => turbines.push(createWindTurbine(p.x, p.z, p.s, p.h)));

// Trees
for (let i = 0; i < 130; i++) {
  const x = (hash(i * 7, i * 13) - 0.5) * 120;
  const z = (hash(i * 11, i * 3) - 0.5) * 120;
  if (!turbinePos.some(p => Math.hypot(p.x - x, p.z - z) < 6))
    createTree(x, z, hash(i, i * 2) > 0.4 ? 'pine' : 'round');
}

// Rocks
for (let i = 0; i < 70; i++) {
  createRock((hash(i * 19, i * 23) - 0.5) * 100, (hash(i * 29, i * 31) - 0.5) * 100);
}

// Flowers
for (let i = 0; i < 30; i++) {
  createFlowerPatch((hash(i * 41, i * 43) - 0.5) * 80, (hash(i * 47, i * 53) - 0.5) * 80);
}

// Clouds
for (let i = 0; i < 14; i++) {
  createCloud((hash(i * 61, i) - 0.5) * 140, 18 + hash(i, i * 67) * 15, (hash(i * 71, i * 73) - 0.5) * 140);
}

// Birds
for (let i = 0; i < 8; i++) {
  createBird((hash(i * 83, i * 89) - 0.5) * 60, 14 + hash(i * 97, i) * 10, (hash(i, i * 101) - 0.5) * 60);
}

const particles = createParticles();

// ─── CAMERA ───
camera.position.set(20, 18, 35);
camera.lookAt(0, 4, 0);

let mouseX = 0, mouseY = 0;
document.addEventListener('mousemove', e => {
  mouseX = (e.clientX / window.innerWidth - 0.5) * 2;
  mouseY = (e.clientY / window.innerHeight - 0.5) * 2;
});

// ─── ANIMATION LOOP ───
const clock = new THREE.Clock();
function animate() {
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();

  // Spin turbine rotors
  turbines.forEach((tb, i) => { if (tb.rotorPivot) tb.rotorPivot.rotation.z -= (0.012 + i * 0.002); });

  // Clouds drift
  clouds.forEach((c, i) => { c.position.x += 0.008 * (1 + i * 0.15); if (c.position.x > 80) c.position.x = -80; });

  // Birds circle
  birds.forEach(b => {
    const d = b.userData;
    d.angle += d.speed * 0.01;
    b.position.set(Math.cos(d.angle) * d.radius, d.baseY + Math.sin(t * 0.5 + d.angle) * 1.5, Math.sin(d.angle) * d.radius);
    b.rotation.y = -d.angle + Math.PI / 2;
    b.children[0].rotation.z = 0.3 + Math.sin(t * d.flapSpeed) * 0.4;
    b.children[1].rotation.z = -0.3 - Math.sin(t * d.flapSpeed) * 0.4;
  });

  // Particles
  const pp = particles.geometry.attributes.position.array;
  for (let i = 0; i < pp.length; i += 3) {
    pp[i] += Math.sin(t * 0.3 + i) * 0.004;
    pp[i + 1] += Math.sin(t * 0.5 + i * 0.1) * 0.002;
    pp[i + 2] += Math.cos(t * 0.2 + i) * 0.003;
  }
  particles.geometry.attributes.position.needsUpdate = true;

  water.material.opacity = 0.55 + Math.sin(t * 0.8) * 0.1;

  // Camera orbit + parallax
  const ca = t * 0.04, cr = 40;
  const tx = Math.cos(ca) * cr + mouseX * 5;
  const tz = Math.sin(ca) * cr + mouseY * 3;
  const ty = 16 + Math.sin(t * 0.08) * 2 - mouseY * 3;
  camera.position.x += (tx - camera.position.x) * 0.018;
  camera.position.y += (ty - camera.position.y) * 0.018;
  camera.position.z += (tz - camera.position.z) * 0.018;
  camera.lookAt(0, 3, 0);

  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
